const DEFAULT_CONNECTION_ID = 'DEFAULT';
export class WsSubscriptionsClient {
    url;
    connections;
    callbacks;
    constructor(baseUrl, path) {
        this.url = `${baseUrl}${path}`;
        this.connections = new Map();
        this.callbacks = new Map();
    }
    connect(connectionId = DEFAULT_CONNECTION_ID) {
        return new Promise((resolve, reject) => {
            const websocket = new WebSocket(this.url);
            this.connections.set(connectionId, websocket);
            this.callbacks.set(connectionId, []);
            websocket.onopen = () => {
                resolve();
            };
            websocket.onerror = (error) => {
                reject(error);
            };
            websocket.onmessage = (event) => this.handleMessage(connectionId, event);
        });
    }
    disconnect(connectionId = DEFAULT_CONNECTION_ID) {
        const websocket = this.connections.get(connectionId);
        if (websocket) {
            websocket.close();
            this.connections.delete(connectionId);
            this.callbacks.delete(connectionId);
        }
    }
    subscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
        const websocket = this.connections.get(connectionId);
        if (websocket && websocket.readyState === websocket.OPEN) {
            const requestId = this.getRandomRequestId(); // TODO: store request id and wait for confirmation
            const request = {
                id: requestId,
                method: 'subscribe',
                params: {
                    contextIds: contextIds,
                },
            };
            websocket.send(JSON.stringify(request));
        }
    }
    unsubscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
        const websocket = this.connections.get(connectionId);
        if (websocket && websocket.readyState === websocket.OPEN) {
            const requestId = this.getRandomRequestId(); // TODO: store request id and wait for confirmation
            const request = {
                id: requestId,
                method: 'unsubscribe',
                params: {
                    contextIds: contextIds,
                },
            };
            websocket.send(JSON.stringify(request));
        }
    }
    addCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
        if (!this.callbacks.has(connectionId)) {
            this.callbacks.set(connectionId, [callback]);
        }
        else {
            this.callbacks.get(connectionId).push(callback);
        }
    }
    removeCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
        const callbacks = this.callbacks.get(connectionId);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index !== -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    handleMessage(connectionId, event) {
        const response = JSON.parse(event.data.toString());
        if (response.id !== null) {
            // TODO: handle non event messages gracefully
            return;
        }
        if (response.error !== undefined) {
            // TODO: handle errors gracefully
            return;
        }
        const callbacks = this.callbacks.get(connectionId);
        if (callbacks) {
            for (const callback of callbacks) {
                const nodeEvent = response.result;
                callback(nodeEvent);
            }
        }
    }
    getRandomRequestId() {
        return Math.floor(Math.random() * Math.pow(2, 32));
    }
}
